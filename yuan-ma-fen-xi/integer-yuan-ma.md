# Integer源码

## 成员变量

```java
@Native public static final int   MIN_VALUE = 0x80000000;

@Native public static final int   MAX_VALUE = 0x7fffffff;

@SuppressWarnings("unchecked")
public static final Class<Integer>  TYPE = (Class<Integer>) Class.getPrimitiveClass("int");

final static char[] digits = {
    '0' , '1' , '2' , '3' , '4' , '5' ,
    '6' , '7' , '8' , '9' , 'a' , 'b' ,
    'c' , 'd' , 'e' , 'f' , 'g' , 'h' ,
    'i' , 'j' , 'k' , 'l' , 'm' , 'n' ,
    'o' , 'p' , 'q' , 'r' , 's' , 't' ,
    'u' , 'v' , 'w' , 'x' , 'y' , 'z'
};

final static char [] DigitTens = {
    '0', '0', '0', '0', '0', '0', '0', '0', '0', '0',
    '1', '1', '1', '1', '1', '1', '1', '1', '1', '1',
    '2', '2', '2', '2', '2', '2', '2', '2', '2', '2',
    '3', '3', '3', '3', '3', '3', '3', '3', '3', '3',
    '4', '4', '4', '4', '4', '4', '4', '4', '4', '4',
    '5', '5', '5', '5', '5', '5', '5', '5', '5', '5',
    '6', '6', '6', '6', '6', '6', '6', '6', '6', '6',
    '7', '7', '7', '7', '7', '7', '7', '7', '7', '7',
    '8', '8', '8', '8', '8', '8', '8', '8', '8', '8',
    '9', '9', '9', '9', '9', '9', '9', '9', '9', '9',
    } ;

final static char [] DigitOnes = {
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    } ;
    
final static int [] sizeTable = { 9, 99, 999, 9999, 99999, 999999, 9999999,
                                  99999999, 999999999, Integer.MAX_VALUE };
//Integer的值
private final int value;

@Native public static final int SIZE = 32;

public static final int BYTES = SIZE / Byte.SIZE;
```

### 首先第一个疑问点，@Native注解是干嘛的

先看一下文档注释

```
Indicates that a field defining a constant value may be referenced from native code. The annotation may
be used as a hint by tools that generate native header files to determine whether a header file is required,
and if so, what declarations it should contain.
Since:1.8
```

翻译一下就是

```
表示定义了一个常量，这个常量可以被native本地方法引用，注释可能被生成本机头文件的工具用作提示以确定是否需要头文件
```

因为和头文件相关，那就去测试一下

先编写一个简单的类，包含这个注释，代码如下

```
import java.lang.annotation.Native;

public class L11 {
    @Native
    public static final int   MIN_VALUE = 0x80000000;

    public static void main(String[] args) throws Exception {
        System.out.println(L11.MIN_VALUE);
    }
}
```

生成class文件，执行命令 javac L11.java 得到class文件

```
javac L11.java
```

生成头文件

```
javah -classpath . -jni L11
```

最终目录下存在的三个文件如下

<div align="left"><figure><img src="../.gitbook/assets/image (2) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

查看L11.h

```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class L11 */

#ifndef _Included_L11
#define _Included_L11
#ifdef __cplusplus
extern "C" {
#endif
#undef L11_MIN_VALUE
#define L11_MIN_VALUE -2147483648L
#ifdef __cplusplus
}
#endif
#endif
```

我们发现存在#define L11\_MIN\_VALUE -2147483648L

说明这个值虽然在Java定义的，但是在头文件会进行定义，然后native的方法就能够使用这个常量了

### 第二个疑问点 Class.getPrimitiveClass("int") 方法的作用

看一下文档注释‘

```
/*
 * Return the Virtual Machine's Class object for the named
 * primitive type.
 */
```

翻译一下是：返回虚拟机的原始类型的Class对象

原始类型在Java中就是byte、boolean、char、short、int、log、float、double

所以Class.getPrimitiveClass("int") 应该是等于 int.class，不过getPrimitiveClass方法是受保护的方法，无法被外部包访问

## 构造器

```
public Integer(int value) {
    this.value = value;
}
```

## valueOf方法

```
public static Integer valueOf(int i) {
    if (i >= IntegerCache.low && i <= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);
}
```

这个方法会使用一个静态内部类IntegerCache

```
private static class IntegerCache {
    static final int low = -128;
    static final int high;
    static final Integer cache[];

    static {
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =
            sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
        if (integerCacheHighPropValue != null) {
            try {
                int i = parseInt(integerCacheHighPropValue);
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            } catch( NumberFormatException nfe) {
                // If the property cannot be parsed into an int, ignore it.
            }
        }
        high = h;

        cache = new Integer[(high - low) + 1];
        int j = low;
        for(int k = 0; k < cache.length; k++)
            cache[k] = new Integer(j++);

        // range [-128, 127] must be interned (JLS7 5.1.7)
        assert IntegerCache.high >= 127;
    }

    private IntegerCache() {}
}
```

这里面最核心的一行就是

```
cache[k] = new Integer(j++);
```

说明会提前建好Integer对象，之后如果数字范围在定义的范围之内，就直接取用，提升效率

我们可以做一下测试，示例代码如下

```
package com.code.source.person.basic;

public class L12 {

    public static void main(String[] args) throws Exception {
        Integer a = 125;
        Integer b = 125;
        System.out.println(a == b);

        Integer c = 1000;
        Integer d = 1000;
        System.out.println(c == d);
    }
}
```

打印结果

<div align="left"><figure><img src="../.gitbook/assets/image (3) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

我们发现可以通过配置java.lang.Integer.IntegerCache.high来配置缓存大小，通过启动参数-XX:AutoBoxCacheMax=配置

我们给启动参数配置配置成2000，再次测试

<figure><img src="../.gitbook/assets/image (4) (1).png" alt=""><figcaption></figcaption></figure>

打印结果如下

<div align="left"><figure><img src="../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure></div>

两次都返回true，说明缓存的Integer范围变大了

## toString方法

```
public static String toString(int i) {
    if (i == Integer.MIN_VALUE)
        return "-2147483648";
    int size = (i < 0) ? stringSize(-i) + 1 : stringSize(i);
    char[] buf = new char[size];
    getChars(i, size, buf);
    return new String(buf, true);
}
```

两个核心方法

stringSize方法：通过比较大小，返回位数

```
static int stringSize(int x) {
    for (int i=0; ; i++)
        if (x <= sizeTable[i])
            return i+1;
}
```

getChars方法

```
static void getChars(int i, int index, char[] buf) {
    int q, r;
    int charPos = index;
    char sign = 0;

    if (i < 0) {
        sign = '-';
        i = -i;
    }

    // Generate two digits per iteration
    while (i >= 65536) {
        q = i / 100;
    // really: r = i - (q * 100);
        r = i - ((q << 6) + (q << 5) + (q << 2));
        i = q;
        buf [--charPos] = DigitOnes[r];
        buf [--charPos] = DigitTens[r];
    }

    // Fall thru to fast mode for smaller numbers
    // assert(i <= 65536, i);
    for (;;) {
        q = (i * 52429) >>> (16+3);
        r = i - ((q << 3) + (q << 1));  // r = i-(q*10) ...
        buf [--charPos] = digits [r];
        i = q;
        if (i == 0) break;
    }
    if (sign != 0) {
        buf [--charPos] = sign;
    }
}
```

### 关键代码1

大于等于65536的数值计算

```
q = i / 100;
// really: r = i - (q * 100);
r = i - ((q << 6) + (q << 5) + (q << 2));
i = q;
buf [--charPos] = DigitOnes[r];
buf [--charPos] = DigitTens[r];
```

r = i - ( q \* 64 + q \* 32 + q \* 4)&#x20;

r = i -（q \* (64 + 32 + 4) ）

&#x20;r = i - (q \* 100)

&#x20;而q又是i/100得到的，所以r就是余数

DigitOnes和DigitTens数组的作用就是直接记录百以内的数字的十位和个位字符

所以通过DigitOnes\[r]直接取到个位数，通过通过DigitOnes\[r] 直接取到十位数字

拿到字符放入到buf中，这样大于等于65536数值的低的两位数字字符就找到了

### 关键代码2

小于65536的数值计算

```
q = (i * 52429) >>> (16+3);
r = i - ((q << 3) + (q << 1));  // r = i-(q*10) ...
buf [--charPos] = digits [r];
```

这段代码在数字小于65536时执行

q = (i \* 52429) >>> (16+3)

我们先随便找个数计算一下

```
int i = 12346;
int q = (i * 52429) >>> (16+3);
System.out.println(q);

int i1 = 42342;
int q1 = (i1 * 52429) >>> (16+3);
System.out.println(q1);

int i2 = 4234233;
int q2 = (i2 * 52429) >>> (16+3);
System.out.println(q2);
```

打印数据如下

<div align="left"><figure><img src="../.gitbook/assets/image (1) (1) (1).png" alt=""><figcaption></figcaption></figure></div>

所以我们猜想，在小于65536范围内的数

做乘以52429再右移19位的操作得到的数据与这个数除以10得到的数据相同。

2的19次方为524288，先乘以一个52429，在除以524288，会有精度丢失，应该是在65536范围内正常，我们可以计算一下

q = (i \* 52429) >>> (16+3)

i \* 52429 / 524288

（1）首先 i 是一个小于65536的数，所以 i 可以取的最大值是65535\
（2）如果让 i 取到最大值为65535，并且要先乘一个数的话 ，要保证不可以溢出，同时可以向右移位，说明符号位是可用的\
所以另外一个乘数可以取到的最大值应该是 无符号位的最大数/65536\
所以是 2的32次方 / 65535\
所以是 4294967296 / 65535 = 65537\
也就是说另外一个乘数应该在65537以下\
（3）计算如下数据\
2的19次方为524288 ，这个数除以10 是52428，是小于63337以下可以取到的精度最高的值\
2的20次方是1048576 ，这个数除以10 是104857 ，已经大于65537，会导致溢出

```
r = i - ((q << 3) + (q << 1)); 
```

r = i - ( q \* 8 + q \* 2)&#x20;

r = i -（q \* (8 + 2) ）&#x20;

r = i - (q \* 10)&#x20;

而q又是i/10得到的，所以r就是余数

赋值操作

```java
buf [--charPos] = digits [r];
```

因为r 只能在0-9中出现，所以结合digits数组可以直接找到余数

```java
if (sign != 0) {
    buf [--charPos] = sign;
}
```

最后依据是正数还是负数，进行填充-操作

## parseInt方法

```java
public static int parseInt(String s, int radix)
            throws NumberFormatException
{
    if (s == null) {
        throw new NumberFormatException("null");
    }

    if (radix < Character.MIN_RADIX) {
        throw new NumberFormatException("radix " + radix +
                                        " less than Character.MIN_RADIX");
    }

    if (radix > Character.MAX_RADIX) {
        throw new NumberFormatException("radix " + radix +
                                        " greater than Character.MAX_RADIX");
    }

    // 返回结果
    int result = 0;
    // 用来标记是否是负数
    boolean negative = false;
    int i = 0, len = s.length();
    // 默认最大值取反
    int limit = -Integer.MAX_VALUE;
    // multmin是为了判断上一步的值乘以进制数的情况下是否会溢出
    int multmin;
    // 处理每一位数字
    int digit;

    if (len > 0) {
        char firstChar = s.charAt(0);
        //符号位判断
        if (firstChar < '0') { // Possible leading "+" or "-"
            if (firstChar == '-') {
                negative = true;
                //负数情况，limit值变成最小负数值
                limit = Integer.MIN_VALUE;
            } else if (firstChar != '+')
                throw NumberFormatException.forInputString(s);

            if (len == 1) // Cannot have lone "+" or "-"
                throw NumberFormatException.forInputString(s);
            i++;
        }
        //multmin是为了判断上一步的值乘以进制数的情况下是否会溢出
        multmin = limit / radix;
        while (i < len) {
            // Accumulating negatively avoids surprises near MAX_VALUE
            // 获取当前字符对应进制的数字
            digit = Character.digit(s.charAt(i++),radix);
            if (digit < 0) {
                throw NumberFormatException.forInputString(s);
            }
            //判断上一位的result的值*进制数之后是否溢出
            if (result < multmin) {
                throw NumberFormatException.forInputString(s);
            }
            //不溢出的情况下，进行result计算
            result *= radix;
            //这步是判断加上digit之后是否溢出，只不过是用的负值进行判断
            if (result < limit + digit) {
                throw NumberFormatException.forInputString(s);
            }
            //因为全用的取反值处理，所以是-=
            result -= digit;
        }
    } else {
        throw NumberFormatException.forInputString(s);
    }
    //添加符号
    return negative ? result : -result;
}
```



